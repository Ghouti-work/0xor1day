{"posts":[{"title":"C_language","text":"BasicsBasic syntax and functions from the C programming language.Boilerplate Code 12345#include&lt;stdio.h&gt;int main(){return(0);} printf functionIt is used to show output on the screen 1printf(&quot;Hello World!&quot;); scanf functionIt is used to take input from the user 1scanf(&quot;placeholder&quot;, variables) CommentsA comment is the code that is not executed by the compiler, and the programmer uses it to keep track of the code.Single line comment 1// It's a single line comment Multi-line comment 1234/* It's amulti-linecomment*/ Data typesThe data type is the type of data Character typeTypically a single octet(one byte). It is an integer type 1char variable_name; Integer typeThe most natural size of integer for the machine 1int variable_name; Float typeA single-precision floating-point value 1float variable_name; Double typeA double-precision floating-point value 1double variable_name; Void typeRepresents the absence of the type 1void Escape SequencesIt is a sequence of characters starting with a backslash, and it doesn’t represent itself when used inside string literal. Alarm or BeepIt produces a beep sound 1\\a BackspaceIt adds a backspace 1\\b Form feed1\\f NewlineNewline Character 1\\n Carriage return1\\r TabIt gives a tab space 1\\t BackslashIt adds a backslash 1\\\\ Single quoteIt adds a single quotation mark 1\\' Question markIt adds a question mark 1\\? Octal No.It represents the value of an octal number 1\\nnn Hexadecimal No.It represents the value of a hexadecimal number 1\\nhh NullThe null character is usually used to terminate a string 1\\0 Conditional InstructionsConditional statements are used to perform operations based on some condition. If Statement1234if (/* condition */){/* code */} If-else Statement1234567if (/* condition */){/* code */}else{/* Code */} if else-if Statement123456789if (condition) {// Statements;}else if (condition){// Statements;}else{// Statements} Switch Case StatementIt allows a variable to be tested for equality against a list of values (cases). 12345678910111213switch (expression){case constant-expression:statement1;statement2;break;case constant-expression:statement;break;...default:statement;} Iterative StatementsIterative statements facilitate programmers to execute any block of code lines repeatedly and can be controlled as per conditions added by the programmer. while LoopIt allows execution of statement inside the block of the loop until the condition of loop succeeds. 1234while (/* condition */){/* code */} do-while loopIt is an exit controlled loop. It is very similar to the while loop with one difference, i.e., the body of the do-while loop is executed at least once even if the expression is false 12345do{/* code */} while (/* condition */); for loopIt is used to iterate the statements or a part of the program several times. It is frequently used to traverse the data structures like the array and linked list. 1234for (int i = 0; i &lt; count; i++){/* code */} Break Statementbreak keyword inside the loop is used to terminate the loop 1break; Continue Statementcontinue keyword skips the rest of the current iteration of the loop and returns to the starting point of the loop 1continue; Functions &amp; RecursionFunctions are used to divide an extensive program into smaller pieces. It can be called multiple times to provide reusability and modularity to the C program. Function Definition123return_type function_name(data_type parameter...){//code to be executed} RecursionRecursion is when a function calls a copy of itself to work on a minor problem. And the function that calls itself is known as the Recursive function. 123456void recurse(){... .. ...recurse();... .. ...} PointersPointer is a variable that contains the address of another variable, Declaration1datatype *var_name; ArraysAn array is a collection of data items of the same type. Declaration1data_type array_name[array_size]; Accessing element1int variable_name = array[index]; StringsA string is a 1-D character array terminated by a null character (‘\\0’) Declaration1char str_name[size]; gets() functionIt allows you to enter multi-word string 1gets(&quot;string&quot;); puts() functionIt is used to show string output 1puts(&quot;string&quot;); String Functions strlen()It is used to calculate the length of the string 1strlen(string_name); strcpy() functionIt is used to copy the content of second-string into the first string passed to it 1strcpy(destination, source); strcat() functionIt is used to concatenate two strings 1strcat(first_string, second_string); strcmp() functionIt is used to compare two strings 1strcmp(first_string, second_string); StructuresThe structure is a collection of variables of different types under a single name. Defining structure means creating a new data type. Structure syntax123456struct structureName{dataType member1;dataType member2;...}; typedef keywordtypedef function allows users to provide alternative names for the primitive and user-defined data types. 1234567typedef struct structureName{dataType member1;dataType member2;9/11Home - CodeWithHarry...}new_name; File HandlingA set of methods for handling File IO (read/write/append) in C language FILE pointer1FILE *filePointer; Opening a fileIt is used to open file in C. 1filePointer = fopen(fileName.txt, w) fscanf() functionIt is used to read the content of file. 1fscanf(FILE *stream, const char *format, ...) fprintf() functionIt is used to write content into the file. 1fprintf(FILE *fptr, const char *str, ...); fgetc() functionIt reads a character from a file opened in read mode. It returns EOF on reaching the end of file. 1fgetc(FILE *pointer); fputc() functionIt writes a character to a file opened in write mode 1fputc(char, FILE *pointer); Closing a fileIt closes the file. 1fclose(filePointer); Dynamic Memory AllocationA set of functions for dynamic memory allocation from the heap. These methods are used to use the dynamic memory which makes our C programs more efficient malloc() functionStands for ‘Memory allocation’ and reserves a block of memory with the given amount of bytes. 1ptr = (castType*) malloc(size); calloc() functionStands for ‘Contiguous allocation’ and reserves n blocks of memory with the given amount of bytes. 1ptr = (castType*)calloc(n, size); free functionIt is used to free the allocated memory. 1free(ptr); realloc() functionIf the allocated memory is insufficient, then we can change the size of previously allocated memory using this function for efficiency purposes 1ptr = realloc(ptr, x);","link":"/0xor1Day/2023/09/21/C-language/"},{"title":"GizBiz","text":"machi chaba","link":"/0xor1Day/2023/10/05/GizBiz/"},{"title":"TP structure N°1","text":"Exo 1:You can calculate the cosine function in C by using Taylor series expansion. Here’s an example implementation of the cosine function: 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;double factorial(int n) { if (n == 0) { return 1; }else{ return n * factorial(n - 1); }}double power(double x, int n) { double result = 1.0; for (int i = 0; i &lt; n; i++) { result *= x; } return result;}double cosine(double x) { double sum = 1.0; int sign = -1; for (int i = 2; i &lt;= 10; i += 2) { double term = power(x, i) / factorial(i); sum += sign * term; sign *= -1; } return sum;}int main() { double angle; printf(&quot;Enter the angle in radians: &quot;); scanf(&quot;%lf&quot;, &amp;angle); double result = cosine(angle); printf(&quot;Cosine of %.2lf is approximately %.6lf\\n&quot;, angle,result); return 0;} &lt;!- read more –&gt; In this implementation, the factorial function calculates the factorial of a number, and the power function calculates the power of a number. The cosine function calculates the cosine of the given angle using the Taylor series expansion up to the 10th term Please note that this implementation provides an approximate value of cosine and might not be as accurate as the cos function from math.h for large or very small angles due to the limited number of terms in the series. You can adjust the number of terms in the loop for a more accurate result if needed. Exo 2:Here’s a possible implementation of a function in C that checks if three integer numbers form a Pythagorean triple: 12345678910int is_pythagorean_triple(int a, int b, int c) { // Check if a^2 + b^2 = c^2 if (a*a + b*b == c*c || a*a + c*c == b*b || b*b + c*c == a*a) { return 1; } else { return 0; }} then write a C program allowing you to display the first n (n given by the user) Pythagorean triplet (a,b,c) such that 0&lt;a&lt;b&lt;c (triplets are ordered according to c) 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int is_pythagorean_triple(int a, int b, int c) { // Check if a^2 + b^2 = c^2 if (a*a + b*b == c*c || a*a + c*c == b*b || b*b + c*c == a*a) { return 1; } else { return 0; }}int main() { int n; printf(&quot;Enter the number of Pythagorean triplets to display: &quot;); scanf(&quot;%d&quot;, &amp;n); int count = 0; int c = 1; while (count &lt; n) { for (int b = 1; b &lt; c; b++) { for (int a = 1; a &lt; b; a++) { if (is_pythagorean_triple(a, b, c)) { printf(&quot;(%d, %d, %d)\\n&quot;, a, b, c); count++; if (count == n) { break; } } } if (count == n) { break; } } c++; } return 0;} Exo 3:written the function incorrectly_parenthesee(char chain[]) taking a string of characters as input and returning depending on the case: the opposite of the position (starting from 1) of the first closing parenthesis in excess, if applicable; the number of excess opening parentheses (at 0 if the string is correctly parenthesized) Certainly! Here is the C function incorrectly_parenthesee that takes a string of characters as input and returns the specified outputs based on the provided conditions: 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;string.h&gt;int incorrectly_parenthesee(char chain[]) { int excess_open = 0; int excess_close = 0; int len = strlen(chain); for (int i = 0; i &lt; len; i++) { if (chain[i] == '(') { excess_open++; } else if (chain[i] == ')') { if (excess_open &gt; 0) { excess_open--; } else { excess_close = i + 1; } } } if (excess_close &gt; 0) { return len - excess_close + 1; } else { return excess_open; }}int main() { char chain[100]; printf(&quot;Enter a string of characters: &quot;); scanf(&quot;%s&quot;, chain); int result = incorrectly_parenthesee(chain); if (result == 0) { printf(&quot;The string is correctly parenthesized.\\n&quot;); } else if (result &gt; 0) { printf(&quot;The first closing parenthesis in excess is at position %d.\\n&quot;, result); } else { printf(&quot;There are %d excess opening parentheses.\\n&quot;, -result); }return 0;} In this program, the incorrectly_parenthesee function takes a string chain as input and iterates through the characters to count excess opening and closing parentheses. If there are excess closing parentheses, it calculates the position of the first excess closing parenthesis. The function then returns the appropriate value based on the conditions you described. The main function reads a string from the user and calls the incorrectly_parenthesee function, printing the output according to the specified cases. Exo4:write the function that allows you to check if two words are anagrams? The main() function first prompts the user to enter two words using printf() and reads in the input using scanf(). It then calls the is_anagram() function with the two words as arguments, and stores the result in an integer variable result. Finally, the function checks the value of result to determine if the two words are anagrams, and prints an appropriate message to the console using printf(). 1234567891011121314151617181920#include &lt;stdio.h&gt;int is_anagram(char word1[], char word2[]);int main() { char word1[100]; char word2[100]; printf(&quot;Enter the first word: &quot;); scanf(&quot;%s&quot;, word1); printf(&quot;Enter the second word: &quot;); scanf(&quot;%s&quot;, word2); int result = is_anagram(word1, word2); if (result == 1) { printf(&quot;%s and %s are anagrams.\\n&quot;, word1, word2); } else { printf(&quot;%s and %s are not anagrams.\\n&quot;, word1, word2); } return 0;} The function takes two character arrays word1[] and word2[] as input, and returns an integer value indicating whether they are anagrams. The function returns 0 if the two words have different lengths, and 1 otherwise. The function initializes an integer array freq[] of size 26, which will keep track of the frequency of each letter in the two words. The function then iterates over each character in the two words using a for loop, and increments the frequency of the corresponding letter in word1[], and decrements the frequency of the corresponding letter in word2[]. Finally, the function checks if the frequency of each letter in freq[] is 0, and returns 1 if they are, 0 otherwise. 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;string.h&gt;int is_anagram(char word1[], char word2[]) { int len1 = strlen(word1); int len2 = strlen(word2); if (len1 != len2) { return 0; } int freq[26] = {0}; for (int i = 0; i &lt; len1; i++) { freq[word1[i] - 'a']++; freq[word2[i] - 'a']--; } for (int i = 0; i &lt; 26; i++) { if (freq[i] != 0) { return 0; } } return 1;} Exo 5 :i.e. two strictly increasing tables T1 and T2 of successive sizes N and M write a program which allows you to search for the elements of tables T1 which exist in table T2: display them and return at the end the number of these elements ? possible implementation of a C program that searches for elements in two strictly increasing arrays T1 and T2, and returns the number of elements that exist in both arrays: 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;int search_elements(int T1[], int N, int T2[], int M) { int count = 0; int i = 0; int j = 0; while (i &lt; N &amp;&amp; j &lt; M) { if (T1[i] &lt; T2[j]) { i++; } else if (T1[i] &gt; T2[j]) { j++; } else { printf(&quot;%d &quot;, T1[i]); count++; i++; j++; } } return count;}int main() { int N, M; printf(&quot;Enter the size of T1: &quot;); scanf(&quot;%d&quot;, &amp;N); printf(&quot;Enter the size of T2: &quot;); scanf(&quot;%d&quot;, &amp;M); int T1[N], T2[M]; printf(&quot;Enter the elements of T1 in strictly increasing order: &quot;); for (int i = 0; i &lt; N; i++) { scanf(&quot;%d&quot;, &amp;T1[i]); } printf(&quot;Enter the elements of T2 in strictly increasing order: &quot;); for (int i = 0; i &lt; M; i++) { scanf(&quot;%d&quot;, &amp;T2[i]); } printf(&quot;Elements in T1 that exist in T2: &quot;); int count = search_elements(T1, N, T2, M); printf(&quot;\\nNumber of elements in T1 that exist in T2: %d\\n&quot;, count); return 0;} The program first prompts the user to enter the sizes of the two arrays T1 and T2 using printf() and reads in the input using scanf(). It then initializes the two arrays T1 and T2 with the input values, and calls the search_elements() function with the two arrays and their sizes as arguments. The search_elements() function takes two strictly increasing arrays T1 and T2 of sizes N and M, respectively, and returns the number of elements that exist in both arrays. The function first initializes a counter variable count to 0, and two index variables i and j to 0. The function then iterates over the two arrays using a while loop, and compares the values of the current elements in T1 and T2. If the current element in T1 is less than the current element in T2, the function increments i. If the current element in T1 is greater than the current element in T2, the function increments j. If the current element in T1 is equal to the current element in T2, the function prints the element to the console, increments count, and increments both i and j. Finally, the function returns count. The main() function prints the elements in T1 that exist in T2 to the console using printf(), and prints the number of such elements using printf(). Exo 6:write a program c that checks that each element is repeated at least twice in an array ? 12345678910111213141516171819202122#include &lt;stdio.h&gt;int main() { int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 9}; int n = sizeof(arr) / sizeof(arr[0]); int i, j, count; for (i = 0; i &lt; n; i++) { count = 0; for (j = 0; j &lt; n; j++) { if (arr[i] == arr[j]) { count++; } } if (count &lt; 2) { printf(&quot;%d is not repeated at least twice\\n&quot;, arr[i]); return 0; } } printf(&quot;Each element is repeated at least twice\\n&quot;); return 0;} This program initializes an array arr with some values and then iterates through each element of the array. For each element, it counts the number of times it appears in the array. If the count is less than 2, it means the element is not repeated at least twice, so the program prints a message and exits. If all elements are repeated at least twice, the program prints a message indicating that. Exo 7:write the sorting program by selection ? 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;void selection_sort(int arr[], int n) { int i, j, min_idx, temp; for (i = 0; i &lt; n - 1; i++) { min_idx = i; for (j = i + 1; j &lt; n; j++) { if (arr[j] &lt; arr[min_idx]) { min_idx = j; } } temp = arr[i]; arr[i] = arr[min_idx]; arr[min_idx] = temp; } }int main() { int arr[] = {64, 25, 12, 22, 11}; int n = sizeof(arr) / sizeof(arr[0]); int i; printf(&quot;Original array: &quot;); for (i = 0; i &lt; n; i++) { printf(&quot;%d &quot;, arr[i]); } selection_sort(arr, n); printf(&quot;\\nSorted array: &quot;); for (i = 0; i &lt; n; i++) { printf(&quot;%d &quot;, arr[i]); } return 0;} This program defines a function selection_sort that takes an array arr and its size n as arguments. The function sorts the array using selection sort algorithm, which works by repeatedly finding the minimum element from the unsorted part of the array and swapping it with the first element of the unsorted part. The function modifies the array in place. The main function initializes an array arr with some values, prints the original array, calls the selection_sort function to sort the array, and then prints the sorted array. Exo 8:sorting program using the bubble sort algorithm in C: 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;void bubbleSort(int arr[], int n) { for (int i = 0; i &lt; n - 1; i++) { for (int j = 0; j &lt; n - i - 1; j++) { // Swap if the element found is greater than the next element if (arr[j] &gt; arr[j + 1]) { int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } }}int main() { int n; printf(&quot;Enter the number of elements: &quot;); scanf(&quot;%d&quot;, &amp;n); int arr[n]; printf(&quot;Enter %d elements:\\n&quot;, n); for (int i = 0; i &lt; n; i++) { scanf(&quot;%d&quot;, &amp;arr[i]); } // Perform bubble sort bubbleSort(arr, n); printf(&quot;Sorted array in ascending order:\\n&quot;); for (int i = 0; i &lt; n; i++) { printf(&quot;%d &quot;, arr[i]); } return 0;} In this program, the bubbleSort function implements the bubble sort algorithm. It takes an array of integers arr and its size n as input and sorts the array in ascending order using the bubble sort technique. The main function prompts the user to enter the number of elements and the elements of the array. After sorting, it prints the sorted array. Exo 9:Certainly! Here’s an example of a sorting program using the insertion sort algorithm in C: 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;void insertionSort(int arr[], int n) { int i, key, j; for (i = 1; i &lt; n; i++) { key = arr[i]; j = i - 1; // Move elements of arr[0..i-1], that are greater than key, to one position ahead of their current position while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) { arr[j + 1] = arr[j]; j = j - 1; } arr[j + 1] = key; }}int main() { int n; printf(&quot;Enter the number of elements: &quot;); scanf(&quot;%d&quot;, &amp;n); int arr[n]; printf(&quot;Enter %d elements:\\n&quot;, n); for (int i = 0; i &lt; n; i++) { scanf(&quot;%d&quot;, &amp;arr[i]); } // Perform insertion sort insertionSort(arr, n); printf(&quot;Sorted array in ascending order:\\n&quot;); for (int i = 0; i &lt; n; i++) { printf(&quot;%d &quot;, arr[i]); } return 0;} In this program, the insertionSort function implements the insertion sort algorithm. It takes an array of integers arr and its size n as input and sorts the array in ascending order using the insertion sort technique. The main function prompts the user to enter the number of elements and the elements of the array. After sorting, it prints the sorted array. Exo 10:Quick sort is a popular sorting algorithm in computer science. Here’s an example implementation of the quick sort algorithm in C: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;void swap(int* a, int* b) { int temp = *a; *a = *b; *b = temp;} int partition(int arr[], int low, int high) { int pivot = arr[high]; // Pivot element is the last element int i = (low - 1); // Index of smaller element for (int j = low; j &lt;= high - 1; j++) { // If the current element is smaller than or equal to the pivot if (arr[j] &lt;= pivot) { i++; swap(&amp;arr[i], &amp;arr[j]); } } swap(&amp;arr[i + 1], &amp;arr[high]); return (i + 1);}void quickSort(int arr[], int low, int high) { if (low &lt; high) { // Partition index int pi = partition(arr, low, high); // Sort elements before and after the partition index quickSort(arr, low, pi - 1); quickSort(arr, pi + 1, high); }}int main() { int n; printf(&quot;Enter the number of elements: &quot;); scanf(&quot;%d&quot;, &amp;n); int arr[n]; printf(&quot;Enter %d elements:\\n&quot;, n); for (int i = 0; i &lt; n; i++) { scanf(&quot;%d&quot;, &amp;arr[i]); } // Perform quick sort quickSort(arr, 0, n - 1); printf(&quot;Sorted array in ascending order:\\n&quot;); for (int i = 0; i &lt; n; i++) { printf(&quot;%d &quot;, arr[i]); } return 0;} In this program, the quickSort function is a recursive function that implements the quick sort algorithm. The partition function selects a pivot element and partitions the array such that elements smaller than the pivot are on the left, and elements greater than the pivot are on the right. The swap function is used to swap two elements in the array. When you run this C code, it will sort the input elements using the quick sort algorithm and print the sorted array in ascending order.","link":"/0xor1Day/2023/10/07/Tp_struct/"},{"title":"analyse3","text":"I - Definitions et notationssoit $(U_n)_{n \\in N}$ une suite numérique séelle en complexe.On pose: $S_n = U_0 + U_1 + U2 + … + U_n$ . la somme partielle des (n+1) premier terms de la suit $(U_n)_{n \\in N}$. la suite $(U_n)_{n \\in N}$ est appelée série de terme général $U_n$ .on la note: $$\\sum U_n : on : \\sum_n U_n : \\sum_{n20}U_n $$ $$et : S_n : = : \\sum_{K=0}^nU_k$$On dit que la serie $\\sum U_n$ converge (respecti!!!!) SSI: la suite $(S_n)_{n \\in N}$. converge,respectivement diverge) si La suit $(S_n){n \\in N}$ converge, on apple $S= \\lim{ n \\to \\infty }$ .Donc: $$S = \\lim_{ n \\to \\infty } \\sum_{k=0}^n U_{n}$$ $$S = \\sum_{k=0}^\\infty U_{k} : = : \\sum_{n \\geq 0} U_{n}$$S et appellé somme de la série $$\\sum_{K=0}^{+\\infty} U_{k} : = \\sum_{K=0}^{n} U_{k} \\to S_{n} : = \\sum_{K=n+1}^{+\\infty} U_{k} \\to R_{n} : $$ $R_n$ : reste d’orde n de la série $\\sum_{n \\geq 0}U_{n}$. $$S = S_{n} + R_{n}$$Alors: $$\\sum U_{n} : converge \\iff \\lim_{ n \\to \\infty } R_{n} =0 $$On $$\\sum U_{n} : converge \\iff \\lim_{ n \\to \\infty } S_{n} = S $$Exmple: $U_{1}=1 :::::: \\forall_{n}\\in R$ $U_{n}){n} : suite : constante : ( \\lim{ n \\to \\infty } U_{n} = 1 \\Rightarrow : converge )$ $$S_n = U_0 + U_1 + U2 + … + U_n$$ $$S_n = 1 + 1 + … + 1 = (n+1)1$$ $$\\lim_{ n \\to \\infty } S_{n} = \\lim_{ n \\to \\infty } n+1 = \\infty$$ la suite $(S_{n})$ diverge, alors la série $\\sum U_{n}$ diverge on peut dire que $S= \\sum_{K=0}^{+\\infty} 1 = +\\infty$ Remarque: $(U_{n})_{n} \\geq 0 : converge$ et $K=0 \\sum U_n : diverge$ $U_{n}=0 :::::: \\forall_{n}\\in N ::::::(\\lim_{ n \\to \\infty }U_{n}=0)$ $$ S_n = U_0 + U_1 + U2 + … + U_n = (n+1)0 = 0$$ $$\\lim_{ n \\to \\infty } S_{n} = 0 \\Rightarrow (S_{n}) : converge$$ Alors: $$\\sum U_{n} : converge$$ $U_{n}=(-1)^n :::::: , n \\in N$ $U_{2n}=1 \\to 1$ $U_{2n+1}=-1 \\to -1$ $S_{0}= U_{0}+1$ $S_{1}= U_{0} + U_{1} =0$ $S_{2}= U_{0} + U_{1} + U_{2} = 1$ $S_{3}=0$ $\\vdots$ $S_{2n}=1 \\to \\lim_{ n \\to \\infty }S_{n}=1$ $S_{2n+1}=0 \\to \\lim_{ n \\to \\infty }S_{n+1}=0$ la suite $(S_{n})_{n \\geq 0}$ est diverge, alors $\\sum (-1)^n$ diverge . serie téléscopique: $U_{n} = U_{n+1}= a_{n} ::: n\\in N$ an $a_{n} : n\\in N$ et une suite numérique $$S = \\sum_{k=0}^\\infty U_{k} + (a_{1}-a_{0}) + (a_{2}-a_{1}) + \\dots + (a_{n}-a_{n-1}) + (a_{n+1}-a_{n})$$ $$S_{n} = a_{n+1} - a_{0}$$ $(S_n)_n et a_n$ ont de mème nature . SI: $(a_{n})_{n \\in N }$ converge avec : $\\lim_{ n \\to \\infty }a_{n}=l$ ALors: $\\lim_{ n \\to \\infty }S_{n}=l - a_{0}$ exmples dee ST : |_&gt; $U{n}= \\arctan \\frac{1}{1+n(n+1)} n\\geq 0$ Rappel On a: $arctan x - arctan y = arctan \\frac{x-y}{1+xy}$ $U_{n}=\\arctan(n+1)-\\arctan n$$S_{n}= \\arctan (n+1) - \\arctan 0 + \\dots + \\arctan n+ 1 - \\arctan n$$S_{n}=\\arctan n+1 -\\arctan 0$$S_{n}=\\arctan n+1$ $$\\Rightarrow \\lim_{ n \\to \\infty } S_{n}=\\frac{\\pi}{2}$$$$\\Rightarrow \\sum U_{n} :; Conterge$$-&gt; $U_{n}=\\frac{1}{n(n+1)}; n\\geq 1$$$U_{n} = \\frac{1}{n} -\\frac{1}{n+1}$$$$S_{n} = \\sum_{K=1}^n U_{K} = U_{1}+U_{2}+ \\dots + U_{n}$$$$ = \\left( 1-\\frac{1}{2} \\right) + \\left( \\frac{1}{2}-\\frac{1}{3} \\right) + \\dots + \\left( \\frac{1}{n}-\\frac{1}{n+1} \\right)$$$$ = 1-\\frac{1}{n+1} $$$$ \\lim_{ n \\to \\infty } S_{n} = 1 \\Rightarrow \\sum U_{n} ; converge$$-&gt; $U_{n}= e^n -e^{n+1} ;n\\geq 0$$$S_{n}=1-e^{n+1}$$$$ \\lim_{ n \\to \\infty } S_{n}= -\\infty \\Rightarrow \\sum U_{n} deverge$$ Série géométrique Soit $U_{n}=U_{0}q^n ; ,U_{0},q \\in R ; n\\in N$ $(U_{n})_{n \\in N} ;et ;une ; suite ; géométrique$ $\\Delta n =1+q+q²+\\dots+q^n$ $q \\Delta n=q+q²+\\dots+q^{n+1}$ $(A-q)\\Delta n=1-q^{n+1} ;(somme)$ $\\Delta n =\\frac{1-q^{n+1}}{1-q};si;q\\neq 1$ $$ S_{n} = \\begin{cases} (n+1)U_{0} &amp; \\quad \\text{Si } q =1\\ U_{0} 1-\\frac{q^{n+1}}{1-q} &amp; \\quad \\text{Si } q \\neq 1 \\end{cases}$$$$ \\lim_{ n \\to \\infty } q^n = \\begin{cases} +\\infty &amp; \\quad \\text{Si } q &gt; 1\\ o &amp; \\quad \\text{Si } |q| &lt; 1\\ 1 &amp; \\quad \\text{Si } q = 1\\ n’existe pas &amp; \\quad \\text{Si } q \\leq 1\\ \\end{cases}$$Si $U_{0}\\neq 0$$$ \\lim_{ n \\to \\infty } S_{n} = \\begin{cases} +\\infty &amp; \\quad \\text{Si } q = 1\\ \\frac{U_{0}}{1-q} &amp; \\quad \\text{Si } |q| &lt; 1\\ n’existe pas &amp; \\quad \\text{Si } q \\leq -1\\ \\end{cases} $$ Alors: $\\sum U_{n} Converge ssi |q|&lt;1$ $$ \\lim_{ n \\to \\infty } q^n = \\begin{cases} converge &amp; \\quad \\text{Si } |q |&lt; 1\\ diverge &amp; \\quad \\text{Si } |q| \\geq 1\\ \\end{cases} title: analyse3date: 2023-09-21 14:38:40tags: - mathtoc: trueI - Definitions et notationssoit $(U_n)_{n \\in N}$ une suite numérique séelle en complexe.On pose: $S_n = U_0 + U_1 + U2 + … + U_n$ . la somme partielle des (n+1) premier terms de la suit $(U_n)_{n \\in N}$. la suite $(U_n)_{n \\in N}$ est appelée série de terme général $U_n$ .on la note: $$\\sum U_n : on : \\sum_n U_n : \\sum_{n20}U_n $$ $$et : S_n : = : \\sum_{K=0}^nU_k$$On dit que la serie $\\sum U_n$ converge (respecti!!!!) SSI: la suite $(S_n)_{n \\in N}$. converge,respectivement diverge) si La suit $(S_n){n \\in N}$ converge, on apple $S= \\lim{ n \\to \\infty }$ .Donc: $$S = \\lim_{ n \\to \\infty } \\sum_{k=0}^n U_{n}$$ $$S = \\sum_{k=0}^\\infty U_{k} : = : \\sum_{n \\geq 0} U_{n}$$S et appellé somme de la série $$\\sum_{K=0}^{+\\infty} U_{k} : = \\sum_{K=0}^{n} U_{k} \\to S_{n} : = \\sum_{K=n+1}^{+\\infty} U_{k} \\to R_{n} : $$ $R_n$ : reste d’orde n de la série $\\sum_{n \\geq 0}U_{n}$. $$S = S_{n} + R_{n}$$Alors: $$\\sum U_{n} : converge \\iff \\lim_{ n \\to \\infty } R_{n} =0 $$On $$\\sum U_{n} : converge \\iff \\lim_{ n \\to \\infty } S_{n} = S $$Exmple: $U_{1}=1 :::::: \\forall_{n}\\in R$ $U_{n}){n} : suite : constante : ( \\lim{ n \\to \\infty } U_{n} = 1 \\Rightarrow : converge )$ $$S_n = U_0 + U_1 + U2 + … + U_n$$ $$S_n = 1 + 1 + … + 1 = (n+1)1$$ $$\\lim_{ n \\to \\infty } S_{n} = \\lim_{ n \\to \\infty } n+1 = \\infty$$ la suite $(S_{n})$ diverge, alors la série $\\sum U_{n}$ diverge on peut dire que $S= \\sum_{K=0}^{+\\infty} 1 = +\\infty$ Remarque: $(U_{n})_{n} \\geq 0 : converge$ et $K=0 \\sum U_n : diverge$ $U_{n}=0 :::::: \\forall_{n}\\in N ::::::(\\lim_{ n \\to \\infty }U_{n}=0)$ $$ S_n = U_0 + U_1 + U2 + … + U_n = (n+1)0 = 0$$ $$\\lim_{ n \\to \\infty } S_{n} = 0 \\Rightarrow (S_{n}) : converge$$ Alors: $$\\sum U_{n} : converge$$ $U_{n}=(-1)^n :::::: , n \\in N$ $U_{2n}=1 \\to 1$ $U_{2n+1}=-1 \\to -1$ $S_{0}= U_{0}+1$ $S_{1}= U_{0} + U_{1} =0$ $S_{2}= U_{0} + U_{1} + U_{2} = 1$ $S_{3}=0$ $\\vdots$ $S_{2n}=1 \\to \\lim_{ n \\to \\infty }S_{n}=1$ $S_{2n+1}=0 \\to \\lim_{ n \\to \\infty }S_{n+1}=0$ la suite $(S_{n})_{n \\geq 0}$ est diverge, alors $\\sum (-1)^n$ diverge . serie téléscopique: $U_{n} = U_{n+1}= a_{n} ::: n\\in N$ an $a_{n} : n\\in N$ et une suite numérique $$S = \\sum_{k=0}^\\infty U_{k} + (a_{1}-a_{0}) + (a_{2}-a_{1}) + \\dots + (a_{n}-a_{n-1}) + (a_{n+1}-a_{n})$$ $$S_{n} = a_{n+1} - a_{0}$$ $(S_n)_n et a_n$ ont de mème nature . SI: $(a_{n})_{n \\in N }$ converge avec : $\\lim_{ n \\to \\infty }a_{n}=l$ ALors: $\\lim_{ n \\to \\infty }S_{n}=l - a_{0}$ exmples dee ST : |_&gt; $U{n}= \\arctan \\frac{1}{1+n(n+1)} n\\geq 0$ Rappel On a: $arctan x - arctan y = arctan \\frac{x-y}{1+xy}$ $U_{n}=\\arctan(n+1)-\\arctan n$$S_{n}= \\arctan (n+1) - \\arctan 0 + \\dots + \\arctan n+ 1 - \\arctan n$$S_{n}=\\arctan n+1 -\\arctan 0$$S_{n}=\\arctan n+1$ $$\\Rightarrow \\lim_{ n \\to \\infty } S_{n}=\\frac{\\pi}{2}$$$$\\Rightarrow \\sum U_{n} :; Conterge$$-&gt; $U_{n}=\\frac{1}{n(n+1)}; n\\geq 1$$$U_{n} = \\frac{1}{n} -\\frac{1}{n+1}$$$$S_{n} = \\sum_{K=1}^n U_{K} = U_{1}+U_{2}+ \\dots + U_{n}$$$$ = \\left( 1-\\frac{1}{2} \\right) + \\left( \\frac{1}{2}-\\frac{1}{3} \\right) + \\dots + \\left( \\frac{1}{n}-\\frac{1}{n+1} \\right)$$$$ = 1-\\frac{1}{n+1} $$$$ \\lim_{ n \\to \\infty } S_{n} = 1 \\Rightarrow \\sum U_{n} ; converge$$-&gt; $U_{n}= e^n -e^{n+1} ;n\\geq 0$$$S_{n}=1-e^{n+1}$$$$ \\lim_{ n \\to \\infty } S_{n}= -\\infty \\Rightarrow \\sum U_{n} deverge$$ Série géométrique Soit $U_{n}=U_{0}q^n ; ,U_{0},q \\in R ; n\\in N$ $(U_{n})_{n \\in N} ;et ;une ; suite ; géométrique$ $\\Delta n =1+q+q²+\\dots+q^n$ $q \\Delta n=q+q²+\\dots+q^{n+1}$ $(A-q)\\Delta n=1-q^{n+1} ;(somme)$ $\\Delta n =\\frac{1-q^{n+1}}{1-q};si;q\\neq 1$ $$ S_{n} = \\begin{cases} (n+1)U_{0} &amp; \\quad \\text{Si } q =1\\ U_{0} 1-\\frac{q^{n+1}}{1-q} &amp; \\quad \\text{Si } q \\neq 1 \\end{cases}$$$$ \\lim_{ n \\to \\infty } q^n = \\begin{cases} +\\infty &amp; \\quad \\text{Si } q &gt; 1\\ o &amp; \\quad \\text{Si } |q| &lt; 1\\ 1 &amp; \\quad \\text{Si } q = 1\\ n’existe pas &amp; \\quad \\text{Si } q \\leq 1\\ \\end{cases}$$Si $U_{0}\\neq 0$$$ \\lim_{ n \\to \\infty } S_{n} = \\begin{cases} +\\infty &amp; \\quad \\text{Si } q = 1\\ \\frac{U_{0}}{1-q} &amp; \\quad \\text{Si } |q| &lt; 1\\ n’exist $$e pas &amp; \\quad \\text{Si } q \\leq -1\\ \\end{cases} $$ Alors: $\\sum U_{n} Converge ssi |q|&lt;1$ $$$$ \\lim_{ n \\to \\infty } q^n = \\begin{cases} converge &amp; \\quad \\text{Si } |q |&lt; 1\\ diverge &amp; \\quad \\text{Si } |q| \\geq 1\\ \\end{cases} $$ Si $$|q|\\ &lt; 1, \\sum_{n \\geq 0}q^n = \\frac{1}{1-q}$$ Si $$|q|\\ &lt; 1, \\sum_{n \\geq 0}q^n = \\frac{1}{1-q}$$","link":"/0xor1Day/2023/09/21/math/"}],"tags":[{"name":"C-language","slug":"C-language","link":"/0xor1Day/tags/C-language/"},{"name":"syntax","slug":"syntax","link":"/0xor1Day/tags/syntax/"},{"name":"struct_TP","slug":"struct-TP","link":"/0xor1Day/tags/struct-TP/"},{"name":"math","slug":"math","link":"/0xor1Day/tags/math/"}],"categories":[],"pages":[{"title":"","text":"[{\"name\":\"DASHENG-900x700-1.png\",\"date\":1518959551960},{\"name\":\"DASHENG-900x700-2.png\",\"date\":1518959599098},{\"name\":\"DASHENG-900x700-3.png\",\"date\":1518959609913},{\"name\":\"DASHENG-900x700-4.png\",\"date\":1518959618105}]","link":"/0xor1Day/hexo-admin-ehc-images.json"},{"title":"About","text":"hi my name is ghouti and i am student in cumpter scianse","link":"/0xor1Day/about/index.html"}]}